====================
PHP入門
====================

PHPとは
===========

| PHPはサーバーサイドで動作するプログラミング言語です。
| 文法はわかりやすさ、習得のしやすさを重視して作られており、初心者でも習得しやすいと言われています。
| 一方で、PHP5以降では本格的なオブジェクト指向プログラミングが可能になり、大規模開発でも多く使われています。
| また多くのライブラリやフレームワークが存在するため開発の手助けになります。
| 2012年の2月6日にIDC Japanが発表した「国内ソフトウェア開発者の実態調査」によれば、国内で最も使われているスクリプト言語だそうです。
| PHPを設置する方法はPHPが動作するサーバーに、HTMLと同様にアップロードするだけです。拡張子はphpとなります。

	   

PHPの文とコメント
=================================

PHPブロック
-------------

| PHPは全て「<?php」で始まり「?>」で終了するPHPブロックの内側で実行されます。
| 終了タグは必要ある場合のみ書いてください。

     .. code-block:: php

	PHPブロックの外側はそのまま出力されます。
	<?php
	echo "PHPブロックの中に書かれた内容がPHPプログラムとして実行されます。";
	?>
	終了タグは省略可能であれば省略します。

PHPの設定情報を出力する
-------------------------

  .. code-block:: php

	<?php
	phpinfo();

| 上記のプログラムをそのままコピーして、PHPという拡張子をつけて保存します。
| 次にブラウザを開いてWebサーバー経由でそのファイルにアクセスしてみてください。
| PHPが正常に動作していれば、PHPの設定情報が表示されるはずです。
| もし、表示されない場合はもう一度設定を見なおしてみてください。

文
---------

  .. code-block:: php

	<?php
	echo 'PHPは文末に「;」を書きます。';
	echo '途中に改行や
	　	スペースがあっても無視されます。';

| PHPは文の区切りにセミコロンを使用します。
| 途中で行が変わったりスペースが入っていても無視されます。


コメント
---------

  .. code-block:: php

	<?php
	echo 'ここはコメントではありません'; //ここが１行コメントです。
	echo 'ここはコメントではありません'; #ここも１行コメントです。
	echo 'ここはコメントではありません';/* ここからブロックコメントです。
	ここもコメントです。
	ここまでコメントです。*/
	echo 'ここはコメントではありません';
	//ここはコメントです。?>PHPブロックの外側にはコメントは適応されません。ここはそのまま出力されます。

| PHPでは１行コメントと、複数行に渡るブロックコメントを使用することができます。

出力
---------

  .. code-block:: php
	
	<?php
	echo 'PHPで出力するときはechoを使います。';
	?>

| PHPでCLIやブラウザで出力するときは、基本的にechoを使います。


エラー設定
=================================

  .. code-block:: php

	<?php
	error_reporting(E_ALL);
	ini_set('display_errors', 'On');

| error_reportingは表示するエラーのレベルを指定することができる関数です。
| PHPを学習するときは、全てのエラーが表示されるように、E_ALLを指定しておきましょう。
| またini_set('display_errors', 'On');と書くことでエラーを画面に出力することができます。
| ただし、実際に公開するときには適切なエラーレベルに設定する必要があります。


変数とスコープ
=================================

変数
---------
  .. code-block:: php

	<?php
	$var  = '全てのPHPの変数は必ず先頭に$がつきます。';
	?>

| PHPの変数は先頭に$をつきます。大文字と小文字が区別されます。

スコープ
---------

| PHPでは関数やメソッド内ではその外側で定義された変数を使用することはできません。
| また、関数やメソッド内で定義された変数をその外側で使うことができません。これをローカルスコープと言います。
| 関数やメソッドの外側で定義された変数はグローバル変数となり、全ての場所で利用、書き換えることができます。


スーパーグローバル変数　$_POST $_GET
============================================

| PHPには予め自動的に定義される変数があります。PHPでは定義済みの変数を書き換えることもできますので注意してください。
| 定義済みの変数にはスーパーグローバル変数という、全てのスコープから参照可能な変数も存在します。
| スーパーグローバル変数には例えば、HTTP POSTで渡された内容を含む$_POSTなどが存在します。


型
=================================

| PHPでは型を宣言する必要はありませんが、全ての変数が型を持っています。型は代入された内容に応じて自動的に割り当てられます。
| また、PHPでは型が自動的に変換されることがあります。

整数型(int)
------------------------------

| 整数型は10進法の他に8進法、16進法に対応しています。

     .. code-block:: php

	<?php
	$i = 18;

倍精度浮動小数点型(double)
------------------------------

| 倍精度浮動小数点型とは整数型で表すことができない実数を入れる型です。

     .. code-block:: php

	<?php
	$d = 4.015;

文字列型(string)
------------------------------

| PHPでは多くの場合、文字列型を使います。

     .. code-block:: php

	<?php
	$a = '文字列型';
	$b = "文字列型";

| 文字列を代入するときは、シングルクォーテーションまたはダブルクオーテーションを使います。
| ダブルクオーテーションの中ではエスケープ文字や変数が展開されますが、シングルクォーテーションの中では展開されません。

     .. code-block:: php

	<?php
	$a = '文字列型';
	$b = "文字 $a 列型";
	echo $b;

| これを実行すると、「文字 文字列型 列型」と出力されますが

     .. code-block:: php

	<?php
	$a = "文字列型";
	$b = '文字 $a 列型';
	echo $b;

| この場合は「文字 $a 列型」となります。

     .. code-block:: php

	<?php
	$a = 'う';
	$b = "あい$aえお";
	echo $b;

| この場合、「あいうえお」が出力されることが期待されるのですが、変数「$aえお」が存在しないというエラーになってしまいます。
| このようなことを防ぐために

     .. code-block:: php
	
	<?php
	$a = 'う';
	$b = "あい{$a}えお";
	echo $b;

| このように{}で変数を囲むようにしましょう。

論理型(bool)
------------------------------

| true/falseの真偽値を入れておく型です。

     .. code-block:: php
	
	<?php
	$flag = true;


配列型(array)
------------------------------

| 複数の値を代入することができます。
| $配列変数名 = array(キー => 値, キー => 値, キー => 値, );の形式で可能です。

     .. code-block:: php

	<?php
	$a = 'りんご';
	$fruits = array('banana' => 'バナナ', 'orange' =>  'オレンジ', 'apple' => $a, 'peach' => '桃');

| 一つの配列に複数の型が混在しても構いません。
| PHPは全て連想配列ですが、キーを指定する必要はありません。

     .. code-block:: php

	<?php
	$fruits = array('バナナ', 'オレンジ', 'りんご', '桃');
	$fruits2 = ['バナナ', 'オレンジ', 'りんご', '桃']; //PHP5.4以降

| このように表記することもできます。この場合は

     .. code-block:: php

	<?php
	$fruits = array(0 => 'バナナ', 1 => 'オレンジ', 2 => 'りんご', 3 => '桃');

| と同じ意味になります。
| 配列の中の値を利用するには、「配列変数名[キー]」のようにして取り出します。

     .. code-block:: php

	<?php
	$fruits = array(0 => 'バナナ', 1 => 'オレンジ', 2 => 'りんご', 3 => '桃');
	$apple = $fruits[2]; // 変数appleには'りんご'が代入される。

| 配列の中に配列を入れることも可能です。それを多次元配列といいます。

     .. code-block:: php

	<?php
	$apple = array('青りんご', '赤りんご', '緑りんご');
	$fruits = array(array('オレンジ', '蜜柑', '柚子'), $apple);
	$blueApple = $fruits[1][0];//青りんご
	$orange = $fruits[0][0];//オレンジ

null型
------------------------------

| 値を持っていないことを意味します。nullを代入するか、値が代入されていない場合にnullとなります。

キャスト
------------------------------

| 下記の場合、自動キャストが発生します。

| 異なる型同士で演算を行う場合
| 特定の型でしか出来ない処理に、異なる型が与えられた場合
| また、文字列型でも処理する双方の値の中身が数字の場合は整数型や倍精度浮動小数点型に自動でキャストします。

     .. code-block:: php

	<?php
	if ('007' == '7.0') {
    	    echo '同じです';
	}
	if (50.0 == "050plus") {
    	    echo '同じです';
	}

| これらは全て「同じです」と表示されます。自動キャストは便利ですが、使い方を間違えるとバグを生む可能性があります。
| 「050plus」というパスワードを設定してたのに、「50」と入力するだけで、入れたら深刻な問題です。
| 比較をするときはなるべく型まで比較するイコール3つ「===」を使いましょう。

var_dump()
------------------------------

| 変数の中身や型を確認したいときはvar_dump()を使いましょう。

     .. code-block:: php

	<?php
	$a = 'apple';
	var_dump($a);//string(5) "apple"
	
| var_dumpに$aを入れると、string(5)"apple"のように出力されます。


演算子
=================================

代入演算子
---------------------------

| 左辺の値を右辺の値と同じにします。

     .. code-block:: php

	<?php
	$a = 'apple'; 

代数演算子
---------------------------

| 加算 +
| 減算 -
| 乗算 =
| 除算 /
| 剰余(割ったあまりを返す) %

     .. code-block:: php

	<?php
	$a = 1 + 2;
	echo $a //3 

複合演算子
---------------------------

| 複合演算子は演算した結果を元の変数に代入したい場合に使います。
| 使い方は「左辺 演算子= 右辺」です。

     .. code-block:: php

	<?php
	$a = 1;
	$a += 2;
	echo $a //3 

| 定型的な演算子もあります。

| インクリメント(整数型の値に1を足す) ++
| デクリメント(整数型の値から1を引く) - -
| 「$a++;」は「$a += 1;」と同意義になります。

     .. code-block:: php

	<?php
	$a = 3;
	$a++;
	echo $a //4 

比較演算子
---------------------------

| 左辺と右辺が等しい場合はtrue(型は比較しない)　==
| 左辺と右辺が等しく型が一致した場合はtrue　===
| 左辺と右辺が等しくない場合はtrue(型は比較しない)　!=
| 左辺と右辺が型まで含めて等しくない場合はtrue　!==
| 右辺が左辺より大きい場合true　<
| 左辺が右辺より大きい場合true　>
| 右辺が左辺以上の場合true　<=
| 左辺が右辺以上の場合true　>=

論理演算子
---------------------------

| 論理積 (両辺ともにtrueならtrue)　&&、and
| 論理和 (どちらかがtrueならtrue)　or 、||
| 排他的論理和 (片方がtrueで、もう片方がfalseの場合true)　xor
| 否定 (falseならtrue)　!

     .. code-block:: php

	<?php
	$a = true;
	$b = false;
	$c = true;
	if ($a && $c) {
    	    echo '真';
	}
	if ($a || $b) {
    	    echo '真';
	}
	if ($b xor $c) {
   	    echo '真';
	}
	if (!$b) {
    	    echo '真';
	}

| 上記は全てtrueになります。

文字列演算子
---------------------------

| PHPでは文字列を繋げるときは「.」を使います。

     .. code-block:: php

	<?php
	$a = 'あい';
	$b = 'えお';
	$c = $a . 'う' . $b;
	echo $c; //あいうえお


制御構造
=================================

PHPの制御構造
---------------------------
| if文、switch文、for文、while文はJavascriptとほぼ同じです。
| ただし、PHPではelse ifをelseifと省略できるなど多少の違いはあります。
| また、PHPの制御構造は同じファイルであれば、PHPブロックを超えて継続します。

     .. code-block:: php

	<?php
	if (true) {
	?>
	この部分はif文がtrueのとき以外は出力されません。
	<?php
	} else {
	?>
	この部分はif文がfalseのとき以外は出力されません。
	<?php
	}

if文(条件分岐)
---------------------------

| if文は「もし条件ならば、処理◯◯を実行する。条件でなければ、処理××を実行する」という制御構造です。

     .. code-block:: php

	<?php
	$a = 10;          // 変数aに、10を代入
	if ($a % 2 == 0) {        // もし変数aを2で割った余りが0であれば、以下の処理を実行
    	    echo "偶数";     // 「偶数」と出力
	} else {               // 上記条件に当てはまらなければ、以下の処理を実行
    	    echo "奇数";     // 「奇数」と出力
	}

switch文
---------------------------

| switch文は与えられた変数の値によって処理を分岐する方法です。
| caseの後に想定する変数の値を記述し、case毎に処理を記述します。
| 実行時に変数に渡された値と、caseの後に記述した値が一致すると処理が実行されます。
| それぞれの処理の終了部分には「break;」を記述します。
| 「break;」が記述されていないと以下に続く処理が続いて実行されてしまいますので気をつけましょう。

     .. code-block:: php

	<?php
 	$science = 'chemistry';                            // 変数scienceを定義し、chemistryという文字列を代入 
 	switch ($science) {
     	    case 'physics':                                   // 変数scienceの値がphysicsであれば以下の処理を実行
                echo "私は物理が好きです。";          // 「私は物理が好きです。」と表示する
                break;                                       // switch文を終了
    	    case 'biology':                                  // 変数schienceの値がbiologyであれば以下の処理を実行
                echo "私は生物が好きです。";         // 「私は生物が好きです。」と表示する
                break;                                       // switch文を終了
    	case 'chemistry':                                // 変数schienceの値がchemistryであれば以下の処理を実行       
                echo "私は化学が好きです。";         // 「私は化学が好きです。」と表示する
                break;                                      // switch文を終了
    	default:                                    // 変数scienceの値がphysicsでもbiologyでもchemistryでもない場合以下の処理を実行
                echo "私は理科が好きです。";        // 「私は理科が好きです。」と表示する
                break;                                      // switch文を終了
	}

| 上記の例では変数scienceにchemistryが代入されているので「case 'chemistry':」の処理が実行され、「私は化学が好きです。」と表示されます。

while文
---------------------------
| while文は条件式が真の間だけ、処理を繰り返し実行するものです。
| 以下は"ありがとう"を100回表示するプログラムです。

     .. code-block:: php

	<?php
	$i = 0;                         // 変数iを定義して0を代入
	while ($i < 100) {                   // 変数iが100未満であれば処理を実行、100より大きければ処理を実行せずループを終了
    	    echo "ありがとう";    // 「ありがとう」と表示する
            $i++;                           // 変数iに1を加算する
	}                                  // 条件式へ戻る

for文
---------------------------

| while文以外のもうひとつの繰り返し処理の例が、for文です。
| for文は継続条件式が真の間繰り返し実行されるというものです。定義は以下の通りです。


     .. code-block:: php

	for(初期化式; 継続条件式; 再初期化式){
    	    処理;
	}

| こう書くととても難しいように見えますが、実際的には、限られた回数だけ処理を行ないたい場合、while文より便利です。
| 処理の流れを見てみましょう。

| 1.「初期化式」を実行
| 2.「継続条件式」で真と判定された場合に内部の処理を実行、判定結果が偽の場合ループを終了
| 3.「再初期化処理」を実行 
| ※以降2,3の繰り返しとなります。

| 例えばwhileの例であった、「ありがとう」を100個表示するプログラムをfor文で記述してみましょう。

     .. code-block:: php

	<?php
	                                      // 変数iを定義し0を代入 ※ループの初回のみ実行される
	for ($i = 0; $i < 100; $i++) {      // 変数iが100未満だったら以下の処理を実行、変数iが100より大きければ処理を実行せずにループを終了
    	    echo "ありがとう";    // 「ありがとう」と表示する
	}                                  // 変数iに1を加算し、継続条件式へ再び「i < 100」が真となるか判断する。

foreach文
---------------------------

| foreachは配列など反復可能なデータ構造の中の値を一個づつ処理するのに使います。

     .. code-block:: none

	foreach(配列 as 値){
    	    処理;
	}

| 現在の配列のキーを取得したい場合は

     .. code-block:: none

	foreach(配列 as キー => 値){
    	    処理;
	}

| となります。
| 例えば

     .. code-block:: php

	<?php
	$fruits = array('banana' => 'バナナ', 'orange' =>  'オレンジ', 'apple' => 'りんご', 'peach' => '桃');

| という配列があって、この配列の中身を全て出力したい場合、下記のようにします。

     .. code-block:: php

	<?php
	$fruits = array('banana' => 'バナナ', 'orange' =>  'オレンジ', 'apple' => 'りんご', 'peach' => '桃');
	foreach ($fruits as $fruit) {   //配列の値の数だけ繰り返します。
    	    echo $fruit . PHP_EOL;     //$fruitには現在いる場所の値が入っています。この場合、最初ならバナナ、次はオレンジになります。
	}

| 出力結果

| バナナ
| オレンジ
| りんご
| 桃


関数
=================================

PHPの関数
-----------------

| PHPでは、関数もjavascriptと同じように使うことができます。

     .. code-block:: php

	function 関数名(引数)
	{
    	    処理;
    	    return 戻り値;
	}

     .. code-block:: php

	<?php
	function hello($name)
	{
    	    $answer = "こんにちは、{$name}さん。";
    	    return $answer;
	}

| $nameに"太郎"を渡すと

| ”こんにちは、太郎さん。"     
| が返ってきます。

無名関数
----------------

| PHPでもjavascriptと同じように無名関数を使うこともできます。変数自体が関数オブジェクトとなります。使い方は、変数を代入する時と同じようなやり方です。

     .. code-block:: php

	<?php
	$a = function(){
    	    echo "test";
	};
	$a();


クラス
=================================

| クラスは下記のようにして作成することができます。クラス名はグローバルに定義されるので衝突しないようにしましょう。
| クラス内にはメソッド(関数)とプロパティ(変数)以外のものを置くことはできません。
| オブジェクトをインスタンス化するときは「$object = new ClassName(param);」のようにインスタンス化したあとで「$object->MethodName();」のようにして、クラス内のメソッドを利用します。
| コンストラクタもメソッドの一種ですが、「__construct」という名前に特別な意味があり、インスタンス化(new)するときに自動的に読み込まれます。
| また、インスタンス化するときに与えてあげた引数もコンストラクタに与えてあげるのと同じ意味になります。
| クラス内のメソッドでは$thisという変数に特別な意味があり、自分自身のプロパティやメソッドを呼び出すときに使います。

     .. code-block:: guess

	class クラス名
	{
    	    アクセス修飾子 $プロパティ名;
    	    アクセス修飾子 $プロパティ名 = 'プロパティの初期値';
    	    public function __construct(引数)
    	    {
        	[コンストラクタの実装]
    	    }
    	    アクセス修飾子 function メソッド名()
    	    {
        	$this->[このインスタンスのプロパティ];
        	[メソッドの実装]
    	    }
	}

| $オブジェクト名 = new クラス名(引数);//この処理をインスタンス化という
| $オブジェクト名->プロパティ名;//クラス内のPublic修飾子がついたプロパティ。
| $オブジェクト名->メソッド名;//クラス内のPublic修飾子がついたメソッド。
| クラスは個別の何かではありません。例えば、ツイッターのアカウントの振る舞いを定義したTwitterAccountクラスがあったとします。
| この場合、@uhero_PRというアカウントはTwitterAccountクラスをインスタンス化したオブジェクトです。
| ではTwitterAccountにはどのような振る舞いが必要か考えてみましょう。
| TwitterAccountが持つべきプロパティは、ユーザーID(userId)、プロフィール(profile)、場所(location)、URL(url)です。
| TwitterAccountが持つべきメソッドはそれらを登録したり取得したりする機能です。
| 初期値を登録するときはコンストラクタでできるようにしましょう。それを実装してみるとこのようになります。


     .. code-block:: php

	<?php
	class TwitterAccount
	{
    	    private $name;
    	    private $profile;
    	    private $location;
    	    private $url;
    	    /**
     	    * これがコンストラクタです。
     	    * 引数で受け取ったものを、プロパティにセットしています。
     	    */
    	    public function __construct($name, $profile, $location, $url)
    	    {
       	        $this->name = $name;
        	$this->profile = $profile;
        	$this->location = $location;
        	$this->url = $url;
    	    }
    	    /**
     	    * ユーザー名を取得するためのメソッドです。
     	    */
    	    public function getName()
    	    {
        	return $this->name;
    	    }
    	    /**
     	    * プロフィールを取得するためのメソッドです。
     	    */
    	    public function getProfile()
    	    {
        	return $this->profile;
    	    }
    	    /**
     	    * 場所を取得するためのメソッドです。
     	    */
    	    public function getLocation()
    	    {
        	return $this->location;
    	    }
    	    /**
     	    * URLを取得するためのメソッドです。
     	    */
    	    public function getUrl()
    	    {
        	return $this->url;
    	    }
	}

	$uhero_PR = new TwitterAccount('株式会社ユヒーロ', '株式会社ユヒーロ公式アカウントです。サイトの更新情報や、社内の取り組みなどツイートしてまいります。', '日本橋', 'uhero.co.jp'); //インスタンス化

	echo $uhero_PR->getName(); //uhero_PRはTwitterAccountなので、getName()することができる。


クラスの継承と抽象クラス
=================================

クラスの継承
--------------

| 継承はクラスのメソッドやプロパティを引き継いで、新しいクラスを作ることです。


     .. code-block:: none

	class クラス名 extends 親クラス名
	{
	}

| 例えば、Userというクラスがあったとします。その中で特にAdminUserというクラスを別に作ることになりました。
| しかし、ほとんどの機能はUserと共通だった場合は同じことを書くのは面倒ですし、メンテナンス時に書き換える場所を増やしてしまうことになります。
| このような場合はUserクラスを継承し、異なる部分のみAdminUserクラスに実装します。
| そうするとAdminUserクラスでは、Userのメソッドをあたかも自分自身のメソッドのように呼び出すことができます。
| また、親クラスと同じ名前を子クラスで定義するとオーバーライドといって上書きされます。
| ただし、メソッドの場合、上書き元と引数の数が違う場合はエラーになります。
| その場合はオーバーライドしたメソッドにしか存在しない引数にデフォルト値を設定することで動作するようになります。

     .. code-block:: guess

	<?php
	class User
	{
    	    private $userId;
    	    private $password;
    	    /*
     	    * 新規登録のメソッドです。
     	    */
     	    public function __construct($userId, $password)
     	    {
        	$this->userId = $userId;
        	$this->password = $password;
     	    }
     	    /*
      	    * 記事を投稿するメソッドです。
      	    */
     	    public function submit($text)
     	    {
        	[処理];
     	    }
	}

	/*
 	* 管理者ユーザーを管理するクラス
 	*/
	class AdminUser extends User
	{
     	    /*
      	    * 管理者は削除することができます。
      	    */
     	    public function delete($id)
     	    {
     	    	[処理];
     	    }
 	}


| AdminUserクラスにはsubmitメソッドは存在しませんが、Userクラスを継承しているため、呼び出すことができます。


     .. code-block:: php

	<?php
	//上記の続き
	$adminUser = new AdminUser('admin', 'pass');
	$adminUser->submit('AdminUserも投稿することができます');

抽象クラス
--------------

| 抽象クラスは、親クラスを直接newするような使い方をしない場合に使います。
| 例えば、学部生の情報を管理するstudentクラスを作ったとします。また各学部ごとにそれぞれクラスを作りました。
| 学部生は全員、学部に所属しているため、全員が所属学部のクラスをインスタンス化することになります。
| その結果、studentクラスを直接インスタンス化することは起きません。このようなクラスを抽象クラスといいます。


     .. code-block:: php

	abstract クラス名
	{
    	    [クラスの中身]
	}

| 抽象クラスはこのように作成します。
| また抽象クラスには抽象的なメソッドを作成することもできます。
| 抽象的なメソッドとはメソッドの存在を宣言するだけで、中身を書かないメソッドのことです。
| メソッドの中身は継承したそれぞれのクラスで書かなくてはいけません。子クラスにそのメソッドが存在しない場合はエラーになります。


     .. code-block:: guess

	<?php
	abstract class Student
	{
    	    private $grade;//学年
    	    private $studentId;//学籍番号
    	    /*
     	    * コンストラクタでセットする
     	    */
    	    public function __construct($studentId, $grade)
    	    {
        	$this->studentId = $studentId;
        	$this->grade = $grade;
    	    }
    	    /*
     	    * 学年を取得するメソッドは全学部共通
     	    */
    	    public function getGrade()
    	    {
        	return $this->Grade;
    	    }
    	    /*
     	    * キャンパス名を取得する抽象メソッド
     	    * 学部によって取得方法が異なるので中身を書くことは出来ないが、
     	    * どの学部生もどこかしらのキャンパスに在籍しているので、共通のメソッドである。
     	    * このクラスを継承した子クラスでも必ず中身を書く必要があることを宣言。
     	    */
    	    abstract public function getCampus();
	}

	/*
 	* 環境情報学部の学生を管理するクラス
 	*/
	class EnvironmentalInformationStudent extends Student
	{
    	    /*
     	    * 抽象メソッドの中身
     	    */
    	    public function getCampus()
    	    {
        	return '湘南藤沢';
    	    }
	}

	/*
	 * 経済学部の学生を管理するクラス
	 */
	class EconomicsStudent extends Student
	{
    	    /*
     	    * 抽象メソッドの中身
     	    */
    	    public function getCampus()
    	    {
        	if ($this->getGrade() <= 2) {
            	 　　　return '日吉';
                }
                return '三田';
    	    }
	}

	$economicsStudent = new EconomicsStudent(21204723, 2);
	$environmentalInformationStudent = new EnvironmentalInformationStudent(81271483, 4);
	echo $economicsStudent->getCampus() . PHP_EOL;
	echo $environmentalInformationStudent->getCampus() . PHP_EOL;

| 上記の例では抽象クラスであるstudentに、getCampusという抽象メソッドを実装し、継承した子クラスで中身を実装してます。
| また、EconomicsStudentクラスでは、$this->getGrade()のように$thisで継承元の親クラスのメソッドを呼び出しています。


インターフェイス
=================================

| インターフェイスは規格統一のための仕組みです。
| 例えば、あるオンラインショップでは本、DVD、CDの3種類のものを扱っています。
| これらを同じように管理できるようにするために、統一された方法で商品番号を取得できるようにします。
| 現実世界で例えるなら統一されたバーコードを必ず商品の右下に配置するような感じでしょうか。
| オブジェクト指向プログラミングの世界では「商品番号を取得するメソッド」が必ずどの商品にも存在するということを規格することで、統一された方法で管理することが可能になります。
| これがインターフェイスです。インターフェイス自体はプログラムには影響は与えませんが、インターフェイスで定義したメソッドが実装されていないとエラーになります。今回の例で言うと、「この店ではここにバーコードを貼るようにしてください」というルールがインターフェイスです。
| このルール自体が消滅しても、全ての商品にバーコードが貼られていれば影響はありませんが、将来のことを考えればあった方がいいですよね。
| また、インターフェイスを使うメリットとしては「特定のインターフェイスを実装しているもの以外を引数として受け付けない」という書き方が可能です。
| 先ほどの例えで言うなら「バーコードを右下に貼るというルール」に従わずに搬入された商品を受け付けないという書き方が可能になります。
| インターフェイスはこのように作成します。


     .. code-block:: php

	interface インターフェイス名
	{
    	    [インターフェイスの定義];
	}

| インターフェイスにはPublicのメソッドの定義のみが可能です。
| 実装はこのように行います。


     .. code-block:: php

	class クラス名 implents インターフェイス名[, インターフェイス名(複数指定も可), ...]
	{
    	    [クラスの中身];
	}

| 先ほどのオンラインショップの例ではこうなります。


     .. code-block:: guess

	<?php
	interface Products
	{
    	    public function getProductNumber();
	}

	class Book implements Products
	{
    	    public function getProductNumber()
    	    {
        	[本の商品番号取得するロジックの実装];
	    }
	}

	class DVD implements Products
	{
    	    public function getProductNumber()
    	    {
        	[DVDの商品番号取得するロジックの実装];
    	    }
	}

	class CD implements Products
	{
    	    public function getProductNumber()
    	    {
        	[CDの商品番号取得するロジックの実装];
    	    }
	}

| 次にこの店の各クラスをインスタンス化したものを取り扱うメソッドを書いてみましょう。
| 引数の$productには本、CD、DVDのどれが入っても大丈夫なようにすると共通で利用出来て便利ですよね。
| 現実世界で例えるなら本、CD、DVDのどれも同じレジで同じように取り扱えるようにするといった感じでしょうか。

     .. code-block:: guess

	<?php
	//続き
	function getProductDetial(Products $product) {
    	    $product->getProductNumber();
    	    [以下省略];
	}

| 引数の$productには各商品クラスをインスタンス化したオブジェクトが入っています。
| 引数に「Products $product」と表記することで、Productsというインターフェイスを実装したクラスをインスタンス化したオブジェクトのみを引数として受け付けるようにすることができます。
| つまり、引数として受け取った$productには必ず商品番号を取得するメソッドが存在することが保証されています。
| だから「$product->getProductNumber();」という書き方が可能になります。
| こうして、複数のクラスのオブジェクトをまとめて取り扱い処理することが可能になります。


例外
================================

| 
| 例外は、何かしらの異常が発生したときに、別の処理を行うときに使います。
| 


     .. code-block:: none

	throw new 例外クラス名([メッセージ]);



| 
| このようにして、例外を発生させることが出来ます。
| 


     .. code-block:: none

	try {
		[処理]
	} catch (例外クラス 変数名) {
		[例外処理]
	}


| 
| 例外が発生する可能性がある場所をtryで囲むことによって、捕捉することが出来ます。
| try文で囲まれてない場所でエラーが発生した場合は、致命的なエラーとなります。
| 
| catchは例外が発生した場合に実行される内容です。
| 例外クラスとは、ExceptionなどPHPに予め定義されているクラスを利用するか、それを継承して作成したクラスです。
| 




課題
=================================

| それではPHPの課題に取り組んでみましょう！


■準備問題
----------------------

| 1〜100までの数値を順に出力しなさい。
| ただし、3で割り切れる場合は「Fizz」、5で割り切れる場合は「Buzz」、3でも5でも割り切れる場合は「FizzBuzz」、
| それ以外は数値をそのまま出力する。出力はコンソール上で行うものとする。
| 狙い : PHPの変数の理解、for文とif文の理解



■第1問
----------------------

| 引数が素数であれば、返り値にtrue、素数でなければ返り値にfalseを返す関数を作成しなさい。
| ただし、素数とは１とその数自身でしか割れない数のことである。
| また、その関数を利用し、100以下の素数を配列形式で出力するプログラムを作成しなさい。
| 狙い : bool型、配列型の理解。関数の理解。


■第2問
----------------------

| 第1問を応用し、次のような配列を作成して出力させなさい。
| ・100以下の素数ではない数を配列のキーとする
| ・そのキーに対する値は、キーの素因数(1と自身を除いた割り切れる数全て)を格納した配列とする
| 狙い : 多次元配列の理解。


■第3問
----------------------

| 整数を引数とし、漢数字を返り値とする関数を作りなさい。
| ただし、以降漢数字は、10は十ではなく一〇とする。21は二十一ではなく二一とする。100は百でなく一〇〇とする。
| 狙い : PHP標準関数、文字列処理の理解。配列の適切な利用。


■第4問
----------------------

| 2問目で作成された配列の中身を全て、3問目の関数を使って、漢数字にして出力しなさい。
| 狙い : 多次元配列の利用、２重ループ。

■第５問
----------------------

| PrimePrinterという名前のクラスを作成し、その中で第４問と同じことをしなさい。
| クラスの外側ではオブジェクトの作成とメソッドの呼び出し以外は記述しないこと。
| 狙い : クラスの入門。外側から呼び出す。外側から呼び出すメソッドをパブリックそれ以外をプライベートにすること。

■第６問
----------------------

| Smartphoneクラスを作成し、下記のプロパティをプライベートで作成しなさい。
| ・電話番号
| ・キャリア名
| ・機種名
| ・OS
| これらのプロパティをコンストラクタでセットできるようにしなさい。
| また、これらのプロパティを返り値とするパブリックメソッドをそれぞれ実装しなさい。
| 電話番号を取得するメソッド名はpublic function getNumberとすること。
|  
| 次に
| Featurephoneクラスを作成し、下記のプロパティをプライベートで作成しなさい。
| ・電話番号
| ・キャリア名
| ・機種名
| ・実行できるアプリ名
| これらのプロパティをコンストラクタでセットできるようにしなさい。
| また、これらのプロパティを返り値とするパブリックメソッドをそれぞれ実装しなさい。
| 電話番号を取得するメソッド名はpublic function getNumberとすること。
|  
| 最後に下記のオブジェクトを作りなさい。
| ・電話番号(080-2222-2222)、キャリア名(docomo)、機種名(iPhone5)、OS(iOS6)のSmartphoneオブジェクト
| ・電話番号(090-7777-7777)、キャリア名(au)、機種名(W61SH)、実行できるアプリ(EZアプリ)のFeaturephoneオブジェクト
| 狙い : コンストラクタの利用、プロパティの使用。



■第７問
----------------------

| 6問目で定義した2つのクラスの共通部分を実装した抽象クラス Mobilephone を作成しなさい。
| また、６問目で作成した各クラスはMobilephoneクラスを継承し、異なる部分のみを実装するように修正しなさい。
| 狙い : abstractの利用、継承の利用。


■第８問
----------------------


| (1)
| AppleProductというインタフェースを作成し、シリアル番号を取得するメソッドを宣言しなさい。
| 次に
| AppleProductをimplementsしたMacクラスを作成し、下記のプロパティを実装しなさい。
| ーシリアル番号
| ー機種名
| ーOS
| ーCPUメーカー
| これらのプロパティをコンストラクタでセットできるようにしなさい。
| また、これらのプロパティを返り値とするパブリックメソッドをそれぞれ実装しなさい。
|  
| (2)
| AppleProductをimplementsしたIPodTouchクラスを作成し、下記のプロパティを実装しなさい。
| ーシリアル番号
| ー機種名
| ーOS
| ー容量
| これらのプロパティをコンストラクタでセットできるようにしなさい。
| また、これらのプロパティを返り値とするパブリックメソッドをそれぞれ実装しなさい。
|  
| (3)
| Smartphoneを継承してIphoneクラスを作り、AppleProductをimplementsしなさい。また下記のプロパティを実装しなさい。
| ーシリアル番号
| このプロパティと継承元のプロパティをコンストラクタでセットできるようにしなさい。
| また、これらのプロパティを返り値とするパブリックメソッドをそれぞれ実装しなさい。
|  
| (4)
| 下記のオブジェクトを作りなさい。
| ・シリアル番号(X001QWERTYUIOP)、電話番号(080-2222-2222)、キャリア(docomo)、機種名(iPhone5)、OS(iOS6) のIphoneオブジェクト
| ・シリアル番号(X09878LKJHGFDS)、機種名(MacBook Pro Retina 13.3)、OS(MacOS X 10.9)、CPUメーカー(Intel) のMacオブジェクト
| ・シリアル番号(C456787TYFTY)、機種名(iPodTouch 4g)、OS(iOS6)、容量(64GB) のIpodTouchオブジェクト
| 狙い : インターフェイスの利用


■第９問
----------------------

| AppleStoreクラスを作成し、下記のプロパティをプライベートで作成しなさい。
| ・在庫（配列形式）
| 在庫プロパティは、AppleProductインターフェイスをimplementsしたオブジェクトのみが追加できる配列である。
| 
| 次に下記のパブリックメソッドを追加しなさい。
| ・在庫内のシリアル番号を全て配列形式で取得できる。
| ・在庫を末尾に追加することができる。引数はAppleProductとする。
| 狙い : インターフェイスの理解、複数クラスの利用。



■第10問
-----------------------

| (1)
| 
| 整数の割り算をする関数divideNumberを作成しなさい。2つ数字の引数を持ち、返り値を1番目の引数を2番目の引数で割った数としなさい。
| ただし、下記の場合は「不正な値です」という例外メッセージを持つ InvalidArgumentException をスローしなさい。
| 
| ・数字以外がどちらかの引数に与えられた場合。
| ・2番目の引数に0が与えられた場合。
| 
| 
| (2)

     .. code-block:: php

	<?php
	$values = array(1, 5, 6, 2, 0, 4, "hogehoge", 7, 3,);
	foreach ($values as $value) {
		[todo];
	}


| 上記のforeach文の中身を書き換え
| ループの内側でtry-catch構文を使いなさい。
| そのtryの内部で(1)で作成した関数を呼び出して出力しなさい。
| ただし、第一引数は15120、第二引数は$valueとすること。
| 
| さらに、tryの内側で関数実行後に「実行しました」と出力する処理を書きなさい。
| また、catchの内側では、発生したエラーメッセージを取得して出力する処理を書きなさい。
| 

| (3)
| 上記(2)で作成したコードにもう一つforeach文を追加し、
| 2つ目のforeach文では例外が発生した場合はエラーメッセージを出力して、
| 処理を終了させるようにしなさい。
| 


■最終課題
----------------------

はじめに、 :download:`tweet.json </_static/tweet.json>` をダウンロードしなさい。

| tweet.jsonを読み込み、ユヒーロ公式アカウントがツイートした時刻を時間別に取得し、下記の形式で出力しなさい。
| ただし、東京の時刻を基準とする。また、機能ごとに適宜クラスに分けて使用すること。
|  
| 例：
| 12時　5回
| 13時　9回
| 14時　10回
| 狙い : 複数クラスの利用。オブジェクト指向の理解、PHP標準の関数の利用。適切な型変換。

■課題の答え
----------------------

 :download:`解答の例 </_static/answer_php.zip>` をダウンロードできます。
